---
layout: post
title: "Tcache & Tache Poisoning"
date: 2025-09-18 21:45:00 +0900
categories: ["sec_tech", "exploit", "heap", "glibc", "tcache"]
tags: ["heap", "glibc", "tcache"]
---

# Tcache & Tcache Poisoning

1. Tcache Structure
2. Safe Linking
3. Tcache Poisoning

## 1. Tcache Structure

Tcache는 glibc 2.26부터 만들어진 thread 마다 할당된 동적 할당 캐시로써 다른 bin보다 가장 먼저 확인되는 캐시이지 
thread 독립적인 캐시이다. 이 tcache는 chunk를 동일한 크기끼리 묶어 놓는데 32바이트부터 시작해 16바이트씩 커져 총 64개의 
묶음을 관리한다. 따라서 tcache에 캐싱되는 chunk는 32바이트부터 1040바이트까지의 chunk가 들어간다. tcache를 구성하는 주요한 구조체로는 
tcache_perthread_struct, tcache_entry가 있다. 이외에 주요한 멤버로는 counts, entries, next, key값이 존재한다. 이들을 살펴보자.
앞서 언급한 주요 구조체 및 멤버는 다음과 같은 구조로 연결되어 있다. 

<img src="/assets/images/tcache_perthread_struct.jpg" alt="tcache structure" style="width: 70%; height: 50%;">

tcache는 fastbin과 같이 성능을 위해 단일 연결 리스트 형식을 취하며, 인접한 chunk와 병합이 일어나지 않고, LIFO(Last In First Out) 방식으로 들어가고 나간다.
여기서 tcache_entry의 next 변수가 단일 연결을 구성하며 자신보다 이전에 해제되었으며 자신과 크기가 같은 chunk의 주소를 갖는다. tcache_entry의 key값은 glibc의 버전에 따라
상이하다. 이 부분은 따로 설명하도록 하겠다. 이렇게 next와 key로 구성된 tcache_entry는 tcache에 들어갈 1개의 chunk를 나타낸다. 이 chunk들의 묶음은 tcache_perthread_struct가 
가지는 counts, entries 배열을 통해 관리된다. 이 두 배열은 모두 64개의 인덱스를 가지며 counts[0], entries[0]은 32바이트 크기의 chunk를 관리하고 counts[1], entries[1]은 48바이트 크기의 chunk를 관리하는 식이다.
counts는 해당하는 chunk 묶음에 chunk가 몇개 있는지를, entries는 각 chunk의 해드 즉, 가장 최근에 해제된 청크의 tcache_entry 포인터를 인자로 가진다. 이들을 소스 코드로 살펴보자면 다음과 같다. 
{% highlight c %}

static __thread tcache_perthread_struct *tcache = NULL;
...

typedef struct tcache_entry
{
  struct tcache_entry *next;
  /* This field exists to detect double frees.  */
  uintptr_t key;
} tcache_entry;

/* There is one of these for each thread, which contains the
   per-thread cache (hence "tcache_perthread_struct").  Keeping
   overall size low is mildly important.  Note that COUNTS and ENTRIES
   are redundant (we could have just counted the linked list each
   time), this is for performance reasons.  */

typedef struct tcache_perthread_struct
{
  uint16_t counts[TCACHE_MAX_BINS];
  tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;

{% endhighlight %}

tcache_perthread_struct는 tcache란 이름으로 만들어졌음을 알 수 있으며, 아래와 같은 테스트 코드로 컴파일하고 gdb로 살펴보면 tcache_perthread_struct가 가지는 counts와 entries에 32바이트에 해당하는 chunk가 몇개가 들어가 있고
가장 최근에 들어간 chunk는 무엇인지 볼 수 있다. 또한 heap 명령어의 결과로 알 수 있 듯이 counts에 들어가는 최댓값은 7인데 이는 TCACHE_MAX_BINS라는 glibc 내부 변수로 결정되며, 이 개수를 초과하는 chunk는 fastbin 혹은 unsorted bin으로 넘어가서 들어간다.
{% highlight c %}

#include <stdlib.h>

int main() {
        void *buf[10];
        int i;
        for(i=0;i<10;i++)
                buf[i] = malloc(0x20);
        for(i=0;i<10;i++)
                free(buf[i]);
        return 0;
}

{% endhighlight %}

![gdb result](/assets/images/gdb_tcache.png)

### Key

tcache_entry의 key라는 값은 glibc 2.28까지는 존재하지 않는 맴버였다. 이는 Double Free를 감지하기 위해 넣은 값으로 tcache에 chunk를 넣으려고 할 때 key가 있을 위치를 검사해 double free를 감지하고 에러를 내는 식이다.
이는 다음과 같은 소스 코드로 살펴 볼 수 있다.

{% highlight c %}
_int_free (mstate av, mchunkptr p, int have_lock)
...
    if (tcache != NULL && tc_idx < mp_.tcache_bins)
      {
	/* Check to see if it's already in the tcache.  */
	tcache_entry *e = (tcache_entry *) chunk2mem (p);

	/* This test succeeds on double free.  However, we don't 100%
	   trust it (it also matches random payload data at a 1 in
	   2^<size_t> chance), so verify it's not an unlikely
	   coincidence before aborting.  */
	if (__glibc_unlikely (e->key == tcache))  // key 값을 검사하여 DFB 검사
	  {
	    tcache_entry *tmp;
	    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
	    for (tmp = tcache->entries[tc_idx];
		 tmp;
		 tmp = tmp->next)
	      if (tmp == e)
		malloc_printerr ("free(): double free detected in tcache 2");
	    /* If we get here, it was a coincidence.  We've wasted a
	       few cycles, but don't abort.  */
	  }
...
{% endhighlight %}

tcache_put은 chunk를 tcache의 리스트에 추가하는 함수로 추가하기 전에 해당 chunk가 free인지 key를 통해 확인한다는 점을 볼 수 있다.
이 key값은 glibc 2.29 - 2.33에서는 tcache_perthread_struct 구조체, 즉 tcache를 가리키는 포인터였다. 그러나 glibc 2.34부터 tcache_key라는 변수에 tcache_key_initialize가 커널에 요청하여 만든 난수를 기록하고 바로 이 tcache_key의 값을 tcache_entry의 key값에 넣는 방식으로 변경되었다. glibc 2.29, 2.34의 소스 코드는 다음과 같다.
{% highlight c %}
// glibc 2.29

typedef struct tcache_entry
{
  struct tcache_entry *next;
  struct tcache_perthread_struct *key; // key값이 tcache_perthread_struct 포인터임
} tcache_entry;

// glibc 2.34

typedef struct tcache_entry
{
  struct tcache_entry *next;
  /* This field exists to detect double frees.  */
  uintptr_t key; // 타입 변경
} tcache_entry;

static __always_inline void
tcache_put (mchunkptr chunk, size_t tc_idx)
{
  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);

  /* Mark this chunk as "in the tcache" so the test in _int_free will
     detect a double free.  */
  e->key = tcache_key; // key에 tcache_key의 값을 넣음
 ...
}

static uintptr_t tcache_key;

static void
tcache_key_initialize (void)
{
  if (__getrandom (&tcache_key, sizeof(tcache_key), GRND_NONBLOCK)
      != sizeof (tcache_key))
    {
      tcache_key = random_bits ();  // tcache_key에 난수를 대입해 놓음
    ...
    }
}
{% endhighlight %}

## 2. Safe Linking

Safe Linking은 glibc 2.32부터 적용된 보호 기법으로 tcache와 fastbin 두 단일 연결 리스트에서 연결에 간단한 암호화를 추가하는 방식이다.
tcache와 fastbin에 적용되는 암호화 방식은 동일하나 이후는 tcache를 기준으로 설명하겠다. 암호화의 대상은 tcache_entry의 next 맴버로 
현재 next를 쓰고자 하는 chunk의 주소(pos)의 하위 12비트를 지우고 원래 next에 적혔던 다음 chunk의 주소(ptr)와 XOR 연산을 수행한 값을 next에 넣는다.
XOR 연산의 특성상 A xor B = C 일 경우 A, B, C이 셋 중 두개를 안다면 나머지 하나를 알 수 있으므로 나중에 복호화도 간단하게 가능하다. 소스 코드 상으로 
암호화는 PROTECT_PTR로 복호화는 REVEAL_PTR로 구현되어 있다. REVEAL_PTR은 복호화를 수행 할 때 next를 쓰고자 하는 chunk의 주소(pos)의 하위 12비트를 지운 값(A)와 암호화된 값(C)로 B를 구해 연결 리스트를 유지함을 볼 수 있다.

{% highlight c %}

#define PROTECT_PTR(pos, ptr) \
  ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))
#define REVEAL_PTR(ptr)  PROTECT_PTR (&ptr, ptr)

{% endhighlight %}

## 3. Tcache Poisoning









