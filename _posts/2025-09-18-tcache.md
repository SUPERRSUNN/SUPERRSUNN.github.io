---
layout: post
title: "Tcache & Tache Poisoning"
date: 2025-09-18 21:45:00 +0900
categories: ["sec_tech", "exploit", "heap", "glibc", "tcache"]
tage: ["heap", "glibc", "tcache"]
---

# Tcache & Tcache Poisoning

1. Tcache Structure
2. Safe Linking
3. Tcache Poisoning

## Tcache

Tcache는 glibc 2.26부터 만들어진 thread 마다 할당된 동적 할당 캐시로써 다른 bin보다 가장 먼저 확인되는 캐시이지 
thread 독립적인 캐시이다. 이 tcache는 chunk를 동일한 크기끼리 묶어 놓는데 32바이트부터 시작해 16바이트씩 커져 총 64개의 
묶음을 관리한다. 따라서 tcache에 캐싱되는 chunk는 32바이트부터 1040바이트까지의 chunk가 들어간다. tcache를 구성하는 주요한 구조체로는 
tcache_perthread_struct, tcache_entry가 있다. 이외에 주요한 멤버로는 counts, entries, next, key값이 존재한다. 이들을 살펴보자.
앞서 언급한 주요 구조체 및 멤버는 다음과 같은 구조로 연결되어 있다. 
![tcache structure image]
tcache는 fastbin과 같이 성능을 위해 단일 연결 리스트 형식을 취하며, 인접한 chunk와 병합이 일어나지 않고, LIFO(Last In First Out) 방식으로 들어가고 나간다.
여기서 tcache_entry의 next 변수가 단일 연결을 구성하며 자신보다 이전에 해제되었으며 자신과 크기가 같은 chunk의 주소를 갖는다. tcache_entry의 key값은 glibc의 버전에 따라
상이하다. 이 부분은 따로 설명하도록 하겠다. 이렇게 next와 key로 구성된 tcache_entry는 tcache에 들어갈 1개의 chunk를 나타낸다. 이 chunk들의 묶음은 tcache_perthread_struct가 
가지는 counts, entries 배열을 통해 관리된다. 이 두 배열은 모두 64개의 인덱스를 가지며 counts[0], entries[0]은 32바이트 크기의 chunk를 관리하고 counts[1], entries[1]은 48바이트 크기의 chunk를 관리하는 식이다.
counts는 해당하는 chunk 묶음에 chunk가 몇개 있는지를, entries는 각 chunk의 해드 즉, 가장 최근에 해제된 청크의 tcache_entry 포인터를 인자로 가진다. 이들을 소스 코드로 살펴보자면 다음과 같다. 
{% highlight c %}

static __thread tcache_perthread_struct *tcache = NULL;
...

typedef struct tcache_entry
{
  struct tcache_entry *next;
  /* This field exists to detect double frees.  */
  uintptr_t key;
} tcache_entry;

/* There is one of these for each thread, which contains the
   per-thread cache (hence "tcache_perthread_struct").  Keeping
   overall size low is mildly important.  Note that COUNTS and ENTRIES
   are redundant (we could have just counted the linked list each
   time), this is for performance reasons.  */

typedef struct tcache_perthread_struct
{
  uint16_t counts[TCACHE_MAX_BINS];
  tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;

{% endhighlight %}

tcache_perthread_struct는 tcache란 이름으로 만들어졌음을 알 수 있으며, 다음과 같은 테스트 코드로 컴파일하고 gdb로 살펴보면 tcache_perthread_struct가 가지는 counts와 entries에 32바이트에 해당하는 chunk가 몇개가 들어가 있고
가장 최근에 들어간 chunk는 무엇인지 볼 수 있다. 또한 heap 명령어의 결과로 알 수 있 듯이 counts에 들어가는 최댓값은 7인데 이는 TCACHE_MAX_BINS라는 glibc 내부 변수로 결정되며, 이 개수를 초과하는 chunk는 fastbin 혹은 unsorted bin으로 넘어가서 들어간다.
{% highlight c %}


{% endhighlight %}




[gdb result]

### Key

tcache_entry의 key라는 값은 glibc 2.28까지는 존재하지 않는 맴버였다. 이는 Double Free를 감지하기 위해 넣은 값으로 tcache에 chunk를 넣으려고 할 때 key가 있을 위치를 검사해 double free를 감지하고 에러를 내는 식이다.
이는 다음과 같은 소스 코드로 살펴 볼 수 있다.

{}
{}

tcache_put은 chunk를 tcache의 리스트에 추가하는 함수로 추가하기 전에 해당 chunk가 free인지 key를 통해 확인한다는 점을 볼 수 있다.
이 key값은 glibc 2.29 - 2.33에서는 tcache_perthread_struct 구조체, 즉 tcache를 가리키는 포인터였다. 그러나 glibc 2.34부터 tcache_key라는 변수에 tcache_key_initialize가 커널에 요청하여 만든 난수를 기록하고
바로 이 tcache_key의 값을 tcache_entry의 key값에 넣는 방식으로 변경되었다. glibc 2.29, 2.34의 소스 코드는 다음과 같다.
{}
{}











