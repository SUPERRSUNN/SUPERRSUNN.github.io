---
layout: post
title: Termination & _rtld_global
date: 2025-09-21 17:55:00 +0900
categories: ["func_pointer","exit"]
tags: ["_rtld_global", "__run_exit_handlers", "exit_function"]
---

# 1. Termination Flow
  
C언어로 작성된 프로그램은 main이 프로그램의 시작이고, return이 프로그램의 끝이라고 생각 할 수 있다. 
그러나 main함수 진입전 혹은 후에 처리되는 함수들이 있다. 이들의 목적은 main 내의 로직을 구현하는 데 필요한 메모리 혹은 커널 단계의 전처리를 
마치고 프로그램 종료 시에는 안전하게 맡아둔 자원을 반환하고 프로그램의 종료를 알리는 데에 있다. 이런 흐름 속에는 exploit에 사용 될 수 있는 함수 포인터, 주소 유츌을 일으킬 수 있는 취약점이 있을 수 있다.
이 글에서는 프로그램이 종료될 때의 후처리 방식을 알아보고, exploit에 사용 될 수 있는 부분을 살펴보겠다.
  
### 1-1. __libc_start_call_main & exit
  
포로그램의 시작은 \_start란 entry point이다. 이 함수는 \__libc_start_call_main을 호출하는 데, 이 함수는 main 함수 내부로 들어가기 전 그리고 후처리를 구현한다. 이 중 후처리를 살펴보기 위해 gdb 디버깅 결과를 살펴보자.
  
{% highlight c %}
#include <stdio.h>

int main() {
        return 0;
}
{% endhighlight %}
  
![](/assets/images/gdb_exit.png)
  
위와 같이 \__libc_start_call_main 함수가 exit 함수를 호출함으로써 프로그램의 종료에 진입하는 것을 볼 수 있다. 또한 step into 명령어로 exit함수의 흐름을 좀 더 살펴보면 다음과 같이 \__run_exit_handlers 함수로 진입하는 것을 볼 수 있다.
  
![](/assets/images/gdb_exit_handler.png)
### 1-2. __run_exit_handlers
  
\__run_exit_handlers 함수는 사용자가 프로그램의 종료시 호출해달라고 등록한 함수를 호출하는 함수이다. 이 호출은 등록한 순서의 역순으로 실행되는데, 이는 나중에 등록한 함수가 이전에 등록한 함수를 의존할 수 있기 때문이다.
소스 코드를 한 번 살펴 보자.

{% highlight c %}
// glibc 2.27

__run_exit_handlers (int status, struct exit_function_list **listp,
		     bool run_list_atexit, bool run_dtors)
{
     ...
  while (true)
    {
      struct exit_function_list *cur;

      __libc_lock_lock (__exit_funcs_lock);

    restart:
      cur = *listp;

      if (cur == NULL)
	{
	  __exit_funcs_done = true;
	  __libc_lock_unlock (__exit_funcs_lock);
	  break;
	}

      while (cur->idx > 0)
	{
	  struct exit_function *const f = &cur->fns[--cur->idx];
	  const uint64_t new_exitfn_called = __new_exitfn_called;

	  __libc_lock_unlock (__exit_funcs_lock);
	  switch (f->flavor)
	    {
	      void (*atfct) (void);
	      void (*onfct) (int status, void *arg);
	      void (*cxafct) (void *arg, int status);

	    case ef_free:
	    case ef_us:
	      break;
	    case ef_on:
	      onfct = f->func.on.fn;
#ifdef PTR_DEMANGLE
	      PTR_DEMANGLE (onfct);
#endif용
	      onfct (status, f->func.on.arg);
	      break;
	    case ef_at:
	      atfct = f->func.at;
#ifdef PTR_DEMANGLE
	      PTR_DEMANGLE (atfct);
#endif
	      atfct ();
	      break;
	    case ef_cxa:
	      f->flavor = ef_free;
	      cxafct = f->func.cxa.fn;
#ifdef PTR_DEMANGLE
	      PTR_DEMANGLE (cxafct);
#endif
	      cxafct (f->func.cxa.arg, status);
	      break;
	    }
	  __libc_lock_lock (__exit_funcs_lock);

	  if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
	    goto restart;
	}

      *listp = cur->next;
      if (*listp != NULL)
	   allocate element.  */
	free (cur);

      __libc_lock_unlock (__exit_funcs_lock);
    }
{% endhighlight %}
  
먼저 주목할 부분은 인자로 전달되는 struct exit_function_list **listp이다. exit_function_list는 exit_function 포인터의 배열이며, 최대 32개의 exit_function 구조체를 가질 수 있다. 또한 next 인자롤 통해 또다른 exit_function_list를 가질 수 있다. 위의 코드를 살펴보면 if (*listp != NULL)를 통해 next가 있다면 해당 exit_function_list를 순회하며 호출한다. exit_function 구조체가 사용자가 등록한 함수의 포인터를 가지고 있는 구조체인데, 이는 등록 방식에 따라 다른 구조를 가지고 있다. 다음 소스 코드를 살펴 보자. 
{% highlight c %}
struct exit_function
  {
    long int flavor;
    union
      {
	void (*at) (void);
	struct
	  {
	    void (*fn) (int status, void *arg);
	    void *arg;
	  } on;
	struct
	  {
	    void (*fn) (void *arg, int status);
	    void *arg;
	    void *dso_handle;
	  } cxa;
      } func;
  };
{% endhighlight %}
  
구조체를 살펴보면 union으로 함수 포인터가 설정되어있으며, flavor는 해당 구조체가 등록된 방식을 의미한다. 함수가 등록되는 방식은 atexit() 함수를 통해, on_exit()을 통해, \__cax_atexit() 함수를 통해 등록될 수있다. 각각 인자가 없는 함수 등록, 인자가 있는 함수 등록, C++을 통한 등록이다. 그래서 on으로 설정된 함수는 *arg를 통해 따로 인자를 받고 해당 방식으로 등록되는 함수는 void (*) (int status, void *arg)란 점 또한 확인 할 수 있다. 이제 실제로 함수를 등록해보자.  
다음은 atexit, on_exit을 통해 함수를 등록하는 예시이다.
{% highlight c%}
//gcc test_atexit.c -o test_atexit.c -g
#include <stdlib.h>
#include <stdio.h>

void test() {
        printf("atexit으로 정상 등록됨.\n");
}



int main() {

        atexit(test);

        return 0;
}

{% endhighlight%}
  
{% highlight c%}
// gcc test_onexit.c -o test_onexit -g
#include <stdlib.h>
#include <stdio.h>

void test(int status, void *arg) {
        printf("on_exit으로 정상 등록.\n");
        printf("전달된 인자는 %s.", arg);
}



int main() {
        char *arg; 
        arg = "On_eXit";
        on_exit(test, arg);

        return 0;
}
{% endhighlight%}

이제 이 프로그램을 실행시켜 보자. 
  
![](/assets/images/gdb_atexit.png)
  
위처럼 \__run_exit_handlers가 등록된 함수 test를 호출시킨다는 점을 알 수 있다. 또한 컴파일한 두 프로그램을 실행시켜보자면,  
![](/assets/images/atexit_onexit.png)  
위처럼 예상한 대로 잘 실행됨을 알 수 있다.
  
### 1-3 Mangling
  
처음에 살펴본 \__run_exit_handlers 소스 코드를 보면 PTR_MANGLE이란 매크로를 살펴 볼 수 있다. 해당 매크로는 일종의 보호 기법으로 Tcahce Poisoning을 막기 위한 보호 기법 Safe Linking처럼 XOR 연산을 통해 함수 포인터를 
암호화하는 매크로이다. 해당 매크로를 살펴보면 다음과 같다. 
{%  highlight c %}
#  define PTR_MANGLE(reg)	xor __pointer_chk_guard_local(%rip), reg;    \
				rol $2*LP_SIZE+1, reg
{% endhighlight %}
  
해당 매크로는 어셈블리어로 구현되어 있는데 \__pointer_chk_guard_local은 랜덤으로 생성되어진 값이고 rol이란 명령어는 비트 순환 연산이다. 비트 순환이란 밀어서 사라진 비트가 반대쪽으로 넘어가는 식의 연산이다. 예시로 살펴보자면 다음과 같다.   
1011100 비트를 왼쪽으로 2칸 순환 연산 -> 1110010  
이는 왼쪽으로 미는 방식, 오른쪽으로 미는 방식 2개가 있을 수 있으며 rol은 Rotate Left의 약어로 왼쪽으로 미는 비트 순환 명령어이다. 또한 LP_SIZE란 매크로는 LONG Pointer Size로 8을 나타낸다. 이를 통해 위 매크로를 이해해보자면,  
임의의 난수와 함수 포인터를 XOR 연산하고 왼쪽으로 17칸 비트 순환 연산을 수행하라 라는 뜻이 된다. 이는 앞서 말했듯이 해당 영역에 Overwirte 공격을 통해 exploit을 수행하는 걸 방해한다. 아까 위에서 컴파일했던 프로그램 atexit함수를 디버깅 해보자. 
![](/assets/images/struct_initial.png)
  
여기서 initial 구조체는 앞서 살펴본 exit_function 구조체이다. 여기에 들어있는 함수 포인터들이 전혀 다른 값을 가지고 있음을 알 수 있다. 앞서 살펴본 암호화 과정을 역순으로 해보자. 먼저 \__pointer_chk_guard_local을 다음과 같이 구해놓는다.  
![](/assets/images/crypt.png)

i그리고 initial 구조체 내의 값에 앞서 살펴본 암호화 과정을 반대로 진행해 준다. 이는 비트 순환 연산을 지원하는 python의 라이브러리 pwn을 사용했다. 
{%  highlight python %}
from pwn import *

ciphertext = 0x1586cf02563272a7

key = 4130914923699869593

plain = ror(ciphertext, 17, 64) ^ key

print("복호화 결과: {0}".format(hex(plain)))
{% endhighlight %}
  
실행 결과는 다음과 같으며 이를 gdb를 통해 disassemble 해보면 다음과 같이 _dl_fini 함수를 가르킨다는 사실을 알 수 있다.

![](/assets/images/decrypt.png)
  
![](/assets/images/gdb_decrypt.png)

### 1-3. \_dl_fini
  
\_dl_fini 함수는 위에서 살펴보았듯이 struct exit_function initial에 들어가 있는 함수로써, 프로그램 실행 시 할당 받아 사용하던 자원들을 정리하는 역할을 맡는다. 동적 할당, 파일, 스레드, 뮤텍스 외 등등이 대상이며 이를 위해 여러 함수들이 호출된다. 해당 함수는 꽤 방대하기 때문에 이 중 exploit에 사용될 수 있는 함수를 살펴보자. 
{% highlight c %}

void
_dl_fini (void)
{   
...
#ifdef SHARED
  int do_audit = 0;
 again:
#endif
  for (Lmid_t ns = GL(dl_nns) - 1; ns >= 0; --ns)
    {
      /* Protect against concurrent loads and unloads.  */
      __rtld_lock_lock_recursive (GL(dl_load_lock)); <----

      unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;
      /* No need to do anything for empty namespaces or those used for
	 auditing DSOs.  */
      if (nloaded == 0
#ifdef SHARED
	  || GL(dl_ns)[ns]._ns_loaded->l_auditing != do_audit
#endif
	  )
	__rtld_lock_unlock_recursive (GL(dl_load_lock));
      else
    ...
{% endhighlight%}
  
위 소스 코드에서 \__rtld_lock_lock_recursive 함수가 GL(dl_load_lock)을 인자로 호출되는 것을 볼 수 있다. GL()는 내부의 문자열 앞에 _를 붙여주는 간단한 매크로이다 따라서 \_dl_load_lock을 인자로 호출하는 함수이다. \__rtld_lock_lock_recursive는 최종적으로 \_rtld_global 구조체 내의 함수 포인터를 가져와 호출하는데 이 부분이 exploit에서 자주 활용된다. \_rtld_global을 살펴보자.
    
# 2. Exploit


