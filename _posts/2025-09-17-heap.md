---
layout: post
title: "Glibc Heap"
date: 2025-09-17 12:49:00 +0900
categories: ["sec_tech", "exploit", "heap", "glibc"]
tage: ["heap", "glibc"]
---

# Glibc Heap & ptmalloc2

1. Heap
2. ptmalloc2
3. Chunk
4. Bins

# 1. Heap
Heap이란 동적으로 할당 받아 사용할 수 있는 메모리 공간을 통틀어 이른다. 
이 정의에서 알 수 있듯이 Heap을 구현하는 방식은 무궁무진하다. 대상이 되는 프로그램이 어떤 특징을 갖느냐에
따라 그에 걸맞는 다양한 할당 및 해제 메커니즘이 적용될 수 있다. 따라서 Linux Kernel의 Heap과 일반 바이너리의 Heap이 다르며
바이너리 내에서도 어떤 Heap을 사용하는 지가 다르다. 여기선 C언어로 작성되었으며, Linux 환경에서 동작하는 바이너리들이 주로 
사용하는 라이브러리 Glibc에 구현되어 있는 Heap의 메커니즘을 살펴본다.

# 2. ptmalloc2
앞서 말했듯 Glibc에 구현되어있는 Heap 동적 할당 메커니즘을 담당하는 부분이다. 
ptmalloc2는 C언어에서 사용하는 함수 malloc(), free()와 같은 동적 할당 함수를 구현하며,
할당과 해제를 관리한다. 여기서 할당과 해제는 메모리의 어떤 물리적 상태를 말하는 것이 아니다.
할당과 해제는 일종의 장부를 통해 구현된다. ptmalloc은 일정한 규칙을 가지고 자신이 가지고 있는 메모리 중
일부를 바이너리가 쓸 수 있게 기록한다. 그리고 바이너리가 해당 영역을 해제하고자 free를 호출하면
이를 자신에게 기록하고 반환받는다. 이 기록이 할당과 해제를 구현하는 핵심이자 전부이다. ptmalloc2에 해당 영역이
할당이라고 기록되면 할당이고, 해제라고 기록되면 해제인 것이다. 그리고 바로 이 부분이 exploit의 핵심이다. 
우리는 이 기록 메커니즘을 잘 이용해 장부를 적절히 바꾸어 원하는 동작을 구현하면 되는 것이다.


![ptmalloc diagram](/assets/images/ptmalloc2_basic.jpg)

이제 ptmalloc2가 구현하는 Heap을 살펴보자.
ptmalloc2의 핵심적인 객체는 chunk, bin, tcache, arena가 있다.
# 3. Chunk
chunk는 ptmalloc이 할당 혹은 해제한 영역을 말하며 헤더와 데이터로 이루어진다.

![ptmalloc chunk](/assets/images/ptmalloc2_chunk.jpg)

할당 혹은 해제한 chunk에서 공통적인 헤더로는 prev_size와 size가 있다. prev_size는 인접한 직전 chunk의 크기를
나타내며 이는 인접한 두 chunk를 묶어 하나의 chunk로 만드는 메커니즘의 구현을 위해 존재한다. 만약 인접한 직전
chunk가 할당된 상태라면 이는 0을 가진다. size는 헤더의 크기를 포함한 크기이다. prev_size 와 size는 각각 8바이트
이므로 요청한 크기보다 16바이트 더 큰 값이 여기에 저장된다. ptmalloc2은 할당을 수행할 때 16바이트 단위로 정렬(Alignment)을 수행한다.이는 chunk의 헤더를 더해 수행된다. 예를 들어 16바이트를 요청하면 17바이트 정렬을 위해 32바이트 크기의 chunk를 할당하는 식이다. 이에 따라 size에 들어가는 값은 언제나 16의 배수가 들어가게 되며 이는 비트로 환산 했을 때 1000 의 배수가 들어간다. 여기서 하위 3비트는 언제나 0임이 보장되므로 각 자릿수는 0 대신 특정 상태를 나타내기 위한 flag 비트가 들어간다. 각 flag는 순서대로 다음과 같다.
### Allocated non main arena(A) 100
해당 chunk가 sub arena에서 할당 받은지를 나타냅니다. (Arena는 추후 설명)
### Mmap'd(M) 010 
해당 chunk가 mmap 시스템콜로 할당된 지를 나타냅니다.
ptmalloc2에는 매우 큰 요청에 대해 mmap으로 chunk를 할당하는 매커니즘이 있습니다.
### Prev-in-use(P) 001
이전 chunk가 사용중인지 나타냅니다. 앞서 살펴본 prev_size와 연계되어 사용됩니다.

이제 해제된 청크만이 갖는 헤더를 살펴보자. 해제된 청크는 fd(forward)와 bk(back)란 헤더를 추가로 가지는 데 이 헤더는 할당
상태의 data 영역에 덧씌워진다. 이는 exploit을 할 때 유용하게 쓰이는 특징으로 Use-After-Free 취약점이 위험한 이유이기도 하다.
이 fd와 bk는 앞서 언급한 ptmalloc2의 장부를 구현하는 핵심 요소이다. 메모리의 동적 할당은 통계적으로 비슷한 크기의 할당 및 해제 요청이 많다. 따라서 ptmalloc2는 해제된 chunk를 관리할 때 그냥 기록하는게 아니라 비슷한 크기끼리 연결 리스트를 구현하여 기록해 둔다.이 연결을 구현하는 부분이 fd와 bk이다. 각 부분에는 자신과 비슷한 크기의 chunk의 주소를 기록해 둔다.

# 4. Bins
앞서 말했듯이 해제된 청크는 그냥 기록되지 않는다. 크기 별로 분류되어 연결 리스트로 관리된다.이 연결 리스트를 bin이라 하며
이 리스트들을 관리하는 묶음을 bins라 한다. 다음과 같이 디버깅용 테스트 코드를 작성하고 pwndbg로 bins를 살펴보자.

{% highlight c %}
// gcc test_bins.c -o test_bins -g 
#include <stdio.h>
#include <stdlib.h>
int main() {
        void *a = malloc(0x3000);
        void *b = malloc(0x3000);
        void *c = malloc(0x3000);
        free(a);
        free(b);
        free(c);
        printf("%p", a);
        printf("%p", b);
        printf("%p", c);
        return 0;
}
{% endhighlight %}

다음과 같이 적당히 breakpoint를 걸어주고 heap 명령어로 확인해 보면 unsorted bin에 free chunk가 들어가 있으며 fd와 bk가 또다른 unsorted bin 내의 free chunk를 가르키는 것을 볼 수 있다. 각 bin 종류들에 따라 연결 방식과 할당 알고리즘이 조금씩 다른데 이는 또다른 포스팅에서 다루어 보도록 하겠다. 
![ptmalloc free list](/assets/images/free_list.png) 
![ptmalloc bins](/assets/images/bins.png) 



 
