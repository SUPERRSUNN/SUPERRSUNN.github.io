---
layout: post
title: "Kernel Analysis, Memory"
date: 2025-09-27 24:10:00 +0900
tags: ["Kernel", "Memory"]
---

# Physical Memory
  
메모리는 컴퓨터를 구성하는 중요한 자원 중 하나이다. 또한 컴퓨터 구조에 따라 메모리를 다른 방식으로 관리한다. 리눅스 커널은 다양한 메모리 관리 방식에 모두 적합하도록 설계되었다. 먼저 어떤 메모리 아키텍쳐가 있는 지 살펴보자.  

## NUMA(Non-Uniform Memory Access)
  
NUMA는 고성능 서버 컴퓨터와 같은 멀티코어 및 멀티 스레딩 시스템에서 일반적인 메모리 아키텍처이다. NUMA 구조는 CPU가 메모리에 접근하는 속도가 다를 수 있다는 점을 전제로 한다.
이로 인해 동등하게 취급되는 메모리가 물리적인 거리 차이로 인해 성능의 차이가 발생할 수 있다. NUMA 구조는 이를 node의 개념을 도입해 해결한다. node는 CPU가 빠르고 동등하게 접근할 수 있는 메모리를 묶어 놓은 것으로 CPU마다 할당된다. node 내의 메모리는 해당 CPU에서 로컬 메모리라고 불리며 이외의 메모리는 원격 메모리라고 한다. 커널은 이 node를 pg_data_t란 구조체로 추상화 한다. 그리고 node들을 pgdat_list란 배열로 관리한다. node는 또 zone으로 나뉜다. zone은 32bit 시스템에서 주로 사용되었으며 64bit 시스템에서는 하위 호환성 때문에 유지하는 개념이다. zone은 node 내의 물리 메모리들을 ZONE_DMA, ZONE_NORMAL, ZONE_HIGHMEM으로 나눈다. ZONE_DMA는 0-16MB에 해당하는 영역으로 Direct Memory Access를 할 수 있도록 예약된 영역이다. ZONE_NORMAL은 모든 작업에 사용될 수 있는 범용 영역으로 커널은 기본적으로 이 영역에서 작업을 수행하려 한다. ZONE_HIGHMEM 영역은 32bit 시스템에서만 사용되는 영역으로 한정된 가상 주소 공간으로 인해 필요한 영역이었지만, 64bit 시스템은 가상 공간이 매우 방대하기에 쓸모가 없어졌다. 

## UMA(Uniform Memory Access)
  
UMA는 CPU가 어떤 메모리에 접근하든지 접근 속도가 일정할 거란 가정을 한다. 이 메모리 아키텍쳐는 일반적인 PC에서 구현하며, 커널은 NUMA에서 구현하는 pg_data_t, node와 같은 개념은 1개만 두어 구현한다. 

## Page Frame
  
물리 메모리는 Page Frame이란 요소로 나뉜다. 이는 대부분 약 4KB(0x1000) 크기로 커널은 각각의 Page Frame을 struct page란 구조체로 다룬다. 이 구조체는 해당 Page Frame의 상태를 저장하며, Buddy 할당자와 같은 메커니즘으로 관리된다. 
전체 메모리는 struct page 구조체의 배열로 관리된다. 이는 다음과 같은 소스 코드를 통해 확인해 볼 수 있다.  
{% highlight c %}
// v6.15.11
//  하위 버전에선 mem_map이란 이름으로 관리. 
struct page *vmemmap;
EXPORT_SYMBOL(vmemmap);

{% endhighlight %}
  
커널은 vmemmap[Page Frame Number] 형식으로 페이지 프레임에 접근할 수 있다. page는 앞서 말했듯이 물리 메모리를 추상화한다. 그렇다면 페이지 프레임에서 어떤 정보를 저장해야 할까? 아래의 소스코드를 통해 확인해 볼 수 있다.
{% highlight c %}

struct page {
	unsigned long flags;		
	
	union {
		struct {	/* Page cache and anonymous pages */			
			union {
				struct list_head lru;
				struct list_head buddy_list;
				struct {
					/* ... */
					unsigned int order;
				};
			};
			struct address_space *mapping;
			union {
				pgoff_t index;
				/* ... */
			};
			unsigned long private;		
		};
        
        /* ... 기타 복합 페이지, 네트워크, ZONE_DEVICE 관련 영역 중략 ... */
        
		struct {	/* Tail pages of compound page */
			unsigned long compound_head;
		};
		
		struct rcu_head rcu_head;
	};
	
	union {
		unsigned int page_type;
		atomic_t _mapcount;
	};
	
	atomic_t _refcount;
    
#ifdef CONFIG_MEMCG
	unsigned long memcg_data;
#elif defined(CONFIG_SLAB_OBJ_EXT)
	unsigned long _unused_slab_obj_exts;
#endif

#if defined(WANT_PAGE_VIRTUAL)
	void *virtual;
#endif
    
    /* ... KMSAN 관련 영역 등 중략 ... */
};

{% endhighlight %}
  
몇가지 구조체를 살펴 보자. mapping, \_mapcount 이 맴버들은 역추적(RMAP, Reverse Mapping)에 사용되는 맴버들이다. mapping은 페이지가 파일 캐시로 사용될 경우, 즉 파일의 내용을 가져와 쓴 메모리일 경우 어떤 파일의 address_space에 매핑되었는 지를 저장한다.이는 파일 매핑일 때 가상 주소를 찾는 데 사용된다. \_mapcount는 이 페이지가 페이지 테이블에서 몇 번 참조되는 지를 나타내며, 이 또한 가상 주소를 찾는 데 사용된다. \_refcount는 이 물리 페이지를 사용하는 주체, 페이지 테이블 엔트리라던지 혹은 다른 커널 객체가 해당 페이지를 참조하는 수를 나타낸다. 그리고 여기서 가장 눈여겨 보아야할 맴버는 바로 flags 맴버이다. 이는 페이지 프레임의 현재 상태를 기록한다. 이 flags 맴버로 나타낼 수 있는 대표적인 정보는 다음과 같다.  

| 플래그 이름 | 비트 번호 | 설명 (의미) |
| :--- | :---: | :--- |
| **PG\_locked** | 0 | 페이지가 **잠금(Locked)** 상태임을 나타냅니다. I/O 작업이나 중요한 업데이트 중 변경을 방지합니다. |
| **PG\_referenced** | 1 | 페이지가 최근에 참조되었음을 나타냅니다. LRU 페이지 교체 알고리즘에 사용됩니다. |
| **PG\_uptodate** | 2 | 페이지의 내용이 백업 저장소(디스크)와 **일치(Upto-Date)**함을 나타냅니다. |
| **PG\_dirty** | 3 | 페이지 내용이 **수정되었음(Dirty)**을 나타냅니다. 디스크로 다시 기록되어야 할(Writeback) 데이터가 있습니다. |
| **PG\_lru** | 4 | 페이지가 **LRU(Least Recently Used)** 페이지 교체 리스트에 속해 있음을 나타냅니다. |
| **PG\_active** | 6 | 페이지가 **액티브(Active)** LRU 리스트에 속해 있음을 나타냅니다. 자주 사용되는 페이지로 간주됩니다. |
| **PG\_slab** | 7 | 페이지가 SLAB/SLUB 할당자에 의해 **커널 객체 할당용**으로 사용되고 있음을 나타냅니다. |
| **PG\_private** | 8 | 페이지가 매핑된 파일의 **사적인 데이터**를 저장하고 있음을 나타냅니다. |
| **PG\_private\_2** | 9 | PG_private와 유사한 두 번째 사적 데이터 플래그입니다. |
| **PG\_writeback** | 10 | 페이지의 내용이 현재 **디스크로 기록 중(Writeback)**임을 나타냅니다. |

# Virtual Memory
  
물리 메모리가 page로 추상화된다면, 가상 메모리는 struct vm_area_struct로 추상화된다. 가상 메모리는 테스크 종속적이다. 테스크는 자신만의 가상 메모리를 가지며, 서로의 가상 메모리를 침범할 수 없다. 따라서 vm_area_struct는 struct task_struct를 통해 접근 할 수 있다. 기본적인 구조는 다음 그림과 같다.  
![](/assets/images/vm_area.jpg)
  
vm_area_struct는 비슷한 권한과 특징을 가지는 페이지를 묶어 vm_area를 추상화하고 이 vm_area들을 vm_next를 통해 연결 리스트로 관리한다. 앞서 살펴본 struct page는 페이지 프레임이 가지는 물리적인 속성을 추상화한다. 이와 마찬 가지로 vm_area_struct는 가상 주소가 가지는 속성을 추상화한다. 이 가상 주소 영역이 어떤 권한으로 만들어졌는지, 파일을 매핑한 영역인지 아닌지, 그리고 Page Fault가 발생했을 때 호출할 함수는 어떤게 있는지 등을 저장한다. 이는 다음과 같이 정리된다.  
  
| vm_flags | Permissions & Policy (페이지 테이블 권한 비트 설정의 기초가 됩니다.)
| :--- | :--- |
VM_READ	    | 읽기(Read) 접근 허용.
VM_WRITE    |	쓰기(Write) 접근 허용.
VM_EXEC	    | 실행(Execute) 접근 허용.
VM_SHARED	| 다른 프로세스와 **공유되는 매핑(Shared Mapping)**인지 여부.
VM_MAYSHARE	| 페이지 테이블 포크 시 공유될 수 있는지 여부.
VM_LOCKED	| 메모리에서 잠겨(mlock) 스왑되지 않아야 하는 영역인지 여부.
  
| Mapping | 설명 
| :--- | :--- |
vm_file	    | 이 영역이 파일에 매핑된 경우 (예: 실행 파일, 공유 라이브러리), 해당 struct file 포인터를 가리킵니다.
vm_pgoff	| 파일 매핑이 시작되는 파일 내 오프셋입니다.
anon_vma	| 이 영역이 파일이 아닌 익명 메모리 (힙, 스택 등)일 경우, RMAP(Reverse Mapping) 정보를 관리하는 구조체를 가리킵니다.
vm_ops      | Page Fault 혹은 메모리 복사 시 필요한 함수 테이블 포인터입니다.
  
참고로 vm_area_struct는 이중 연결 리스트로써 관리되기도 하지만 그림의 mm_struct 내의 mm_mt(v6.1-) 혹은 mm_rb(-v6.1) 자료 구조를 통해 관리되기도 한다. 이제 우리는 가상 메모리가 어떻게 추상화되고 물리 메모리가 어떻게 추상화되는 지 알았다. 그렇다면 커널은 이 두 구조를 어떻게 연결해서 인식할까? 이에 대한 해답은 Page Table에 있다.
  
# Page Table
  
페이지 테이블은 가상 주소를 물리 주소로 바꾸기 위한 정보들을 담는 테이블이다. 현재 리눅스에서는 4계층 페이지 테이블을 채택하고 있다. 4계층 페이지 테이블에서는 PGD(Page Global Directory), PUD(Page Upper Directory), PMD(Page Middle Directory), PTE(Page Table Entry)이 4가지 종류의 테이블로 구성되며 순서대로 인덱싱하여 물리 주소를 찾는다. 레지스터 cr3에는 1번째 테이블 PGD의 물리 주소가 항상 들어있다.(이 테이블들은 테스크 종속적이기 때문에 current가 바뀌면 cr3도 바뀐다) 이를 통해 PGD에 접근하는 데 어떤 인덱스에 접근할 지는 가상 주소를 슬라이싱해서 찾을 수 있다. 전체적인 흐름은 다음 그림과 같다.  
![](/assets/images/page_table.jpg)
  
offset은 찾은 물리 메모리의 페이지 프레임 내에서의 오프셋을 의미한다. 또한 페이지 테이블들에는 단순히 다음 엔트리의 주소만 저장되지는 않는다. 엔트리에 저장된 값의 하위 비트에는 권한과 같은 추가적인 정보가 포함되어있으며, 커널이 해당 물리 페이지를 찾으려 할 때 권한 또한 같이 검사 할 수 있게 한다. 이를 gef의 bata24 플러그인과 qemu를 통해 분석해 보자.   
# 1. qemu에 커널 부팅
  
먼저 qemu로 커널을 부팅하자. 커널의 버전은 상관 없으나 부팅시 -s 옵션을 활성화해 디버깅을 할 수 있게 부팅해준다.

supersunn@supersunn-B650M-D3HP:~/kernel/exploit_tech$ cat run.sh 
qemu-system-x86_64 \
    -cpu qemu64 \
    -m 4G -smp 4,cores=4,threads=1 \
    -kernel ./bzImage \
    -initrd  ./rootfs.cpio \
    -append "root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nopti nokaslr" \
    -netdev user,id=t0 \
    -device e1000,netdev=t0,id=nic0 \
    -nographic \
    -monitor /dev/null \
    -no-reboot \
    -s  <-- 중요

# 2. gef로 원격 디버깅

gef를 실행한 뒤, target remote localhost:1234 명령어를 통해 포트에 대기 중인 qemu와 연결을 한다. 그 뒤 gef 확장 플러그인에서 제공하는 심볼을 찾아주는 명령어인 ksymaddr-remote-apply를 이용해 심볼을 연결해준다. 이제 페이지 테이블을 따라갈 준비가 되었다. 
![](/assets/images/ksymaddr-remote-apply.png)

# 3. 페이지 테이블 따라가기

cr3 레지스터의 값을 확인함으로써 페이지 테이블을 확인해 볼 수 있다. 그러나 cr3 레지스터, 그리고 페이지 테이블에 저장된 값들은 물리 주소가 저장되어있다. 메모리 덤핑을 위해선 가상 주소가 편리하니, gef 플러그인에서 제공하는 phys2page, page2virt 명령어를 사용해서 따라가 보자.
  
![](/assets/images/page_table2.png)
  
테이블에 저장된 값들은 전부 정렬되어있다. 이 때문에 하위 12비트는 주소를 나타내지 않으며, flag로 사용된다. 여기서 주목할 점은 flag가 4번째 테이블에만 있는 것이 아닌, 전 테이블에 걸쳐 설정될 수 있다는 것이다. 리눅스에서 페이지 테이블을 통해 페이지 프레임에 접근할 때 이 flag들을 1차적으로 검사한다. 또한 상위 페이지 테이블에 설정된 권한보다 느슨한 권한은 하위로 지정된 테이블에 들어갈 수 없다. 예를 들어 1계층 테이블의 1번째 엔트리가 flag가 R로 설정되어있다면 그 1번째 엔트리가 가르키는 2계층 페이지 테이블에 있는 값들은 flag가 R/W일 수는 없다는 뜻이다. 이 flag들에는 권한 뿐만 아니라 사용자/슈펴바이저 접근 권한 U/S, 페이지가 물리 메모리에 실제로 적재된 지를 나타내는 Present, 파일 매핑 시 해당 파일의 내용을 변경한 여부를 나타내는 Dirty, 해당 물리 프레임이 접근된 적있는 지를 나타내는 Access 등이 있다. 




